# Nested loop join
두 테이블을 결합하는데 사용되는 가장 간단한 형태의 조인 알고리즘.
쿼리 구조와 데이터 분포를 고려하여 선택됨.
## 동작 방식
1. 외부 반복문(Outer Loop) 1
	- 외부 테이블(기본적으로 작은 테이블)의 각 행을 기준으로 내부 반복문을 실행한다.
2. 내부 반복문(Inner Loop) M
	- 내부 테이블(기본적으로 큰 테이블)의 모든 행을 반복하여 외부 반복문의 각 행과 비교한다.
	- 외부 반복문의 각 행에 대해 내부 테이블의 모든 행을 순회하며 일치하는 행을 찾는다.
3. 조인 조건 검사
	- 외부 반복문의 각 행과 내부 반복문의 각 행 간에 조인 조건을 검사하여 일치하는 행을 결정.
	- 일치하는 행이 발견되면 조인 조건에 따라 결과에 추가됨.
## 적용 상황
- 작은 크기의 테이블을 기준으로 대용량 테이블을 조인해야 할 때 효율적.
- 보통 [[OLTP성 환경의]] 쿼리에서 적절, 대량 테이블 조인하는 방식은 적절하지 않음.
- 외부 테이블의 크기가 내부 테이블보다 작고, 내부 테이블에 인덱스가 존재하지 않을 때 주로 사용.
- 외부 테이블을 스캔하는 횟수는 외부 테이블의 행 수와 동일하며, 내부 테이블을 스캔하는 횟수는 외부 테이블의 행 수와 내부 테이블의 행 수를 곱한 것.
- join 칼럼에 index가 걸려있지 않으면, 한 건씩 전부 Full Scan하기 때문에 내부 반복 테이블의 Index 구성전략이 중요한 요소임.

## 장단점
- 장점
	- 작은 테이블을 기준으로 대용량의 테이블을 조인할 때 효율적.
	- 메모리 사용이 적어 특정 상황에서 메모리 부담이 적음
- 단점
	- 대용량 테이블을 조인할 때 성능이 저하될 수 있음.
	- 외부 테이블의 각 행마다 내부 테이블을 전체 순회하기 때문에 처리 시간이 오래 걸릴 수 있음.


# Sort Merge Join(정렬 병합 조인)
입력 테이블의 크기와 인덱스 유무, 쿼리 조건 등을 고려하여 선택됨.
## 동작 방식
- 중첩 for문과 유사하나, join테이블을 join칼럼 기준으로 정렬하고 나서 join함.
- 두 개의 입력 테이블이 정렬된 상태로 제공되어야 한다. 각 입력 테이블은 조인 조건에 해당하는 열을 기준으로 정렬됨.
- 정렬된 두 테이블을 병합하는 과정에서 각 테이블에서 동일한 조건을 만족하는 행을 찾아 조인.
- 이때 두 테이블이 정렬되어 있어야 하므로, 정렬 작업이 추가되어 성능에 영향을 줄 수 있음.

## 적용 상황
- Inner table에 적절한 Index가 없어서 nested loop join가 적절하지 않을 때 사용.
- 범위로 join하는 경우 적절, Equal join은 적절하지 않음.
- 일반적으로 입력 테이블의 크기가 크고, index를 통한 접근이 적합하지 않을 때 사용.
- 대용량 테이블 간의 조인을 수행할 때 성능이 우수. 특히. 테이블의 크기가 유사하고, 메모리에 한번에 로드할 수 없을 정도로 크지만 디스크에서 직접 읽을 수 있는 크기일 때 적합.
- Table Random Access가 일어나지 않고 정렬 작업이 PGA영역에서 수행되어 경합이 발생하지 않아 성능 유리.

## 장단점
- 장점
	- 대용량 테이블 간의 조인에서 효율적
	- 병렬 처리를 통해 성능을 높일 수 있음.
- 단점
	- 입력 테이블이 정렬되어 있어야해서 정렬 작업이 추가로 필요할 수 있음.
	- 정렬된 상태로 데이터를 유지하는 오버헤드가 발생할 수 있음.
	- 메모리나 디스크 공간에 큰 부하를 줄 수 있음.

# Hash Join
일반적으로 대량의 데이터를 처리할 때 효율적.
옵티마이저가 자동으로 선택

## 동작 방식
1. 해시 테이블 구성
	- 두 테이블 중 일반적으로 작은 테이블을 기준으로 해시 테이블을 생성. 
	- 기준 테이블의 각 행에서 해시 함수를 사용하여 해시 키를 생성하고, 해당 키에 대응하는 버킷에 행을 저장.
2. 해시 테이블 생성
	- 해시 테입르
3. 조인 수행

