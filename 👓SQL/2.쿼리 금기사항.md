# 다룰내용
- index사용을 위해 쿼리 작성시 필수 준수 조건
- Search Argument란?
- Non-SARG 유형
- 조건절 상수화 이슈
- 테이블 변수 최적화 이슈
- 사례들

# 1.SARG(Search Argument)란?

## 1) 이번 내용들은 아래 조건으로 달라질 수 있다
1. SQL Server 버전
2. SQL Server Edition
3. 인덱스의 유형(클러스터형 vs. 비클러스터형)
4. 기본적으로 비클러스터형 인덱스를 기준으로 다룬다.


## 2)SARG(Search Argument , 검색 인수)
- Predicate(조건자, 조건식)에서 검색 대상 및 범위를 `제한할 수 있는 식`
- 해당 열에 인덱스 사용 및 쿼리 최적화를 위한 필요 조건
- Predicate  : WHERE절, HAVING절, JOIN조건처럼 bool값으로 사옹되는 것.
- 기본적으로 최대한 서치 아규먼트를 만족하도록 검색 조건을 작성해야 한다.


# 2.Non-SARG : Index 사용 방해 요소 
#### 'Index 사용을 위한' SQL 쿼리 작성시 필수 준수 조건

## 1)Non-SARG (비 검색 인수)
- 인덱스 사용이나 쿼리 최적화에 방해 요소
- 불필요한 열/행 참조하거나 Index열에 부정형 사용 주의
- 검색을 제한하지 않는 식(테이블 다 뒤짐)


## 2-2.Non-SARG 대표 유형

### 불필요한 데이터(열,행) 참조 (a)-오버헤드

#### 1. 전체 칼럼 참조는 지양하자.

1. 
	1. 전체칼럼 참조는 지양
		1. 대용량데이터(Large object) 열이 포함되어 있으면 메모리,네트워크,클라이언트 버퍼 등에서 과부하를 일으킬 수 있다.
	2. 불필요한 열 참조 지양
		```
		SELECT OrderDate FROM dbo.Orders 
		SELECT OrderID , OrderDate FROM dbo.Orders
		```
		1. OrderID 열에 인덱스가 있다면 두 쿼리는 실행 계획, 실행 방식, 처리하는 데이터 양이 차이 나게 된다.
	3. 불필요한 행 검색 (사례)
		```
		SELECT * FORM 웹사이트_오류_로그
		WHERE 작성일자 BETWEEN '20201001' 
		AND '20201001 23:59:59'
		ORDER BY 작성일자 DESC (500,000건 발)
		```
		1. Client에서 소비하지 못하는 데이터
			1. 추가 검색 조건이나 적절한 TOP(Paging)처리 필요
		2. 총 불러오는 데이터 수의 데이터 크기만큼  메모리를 확보하고, order by 가 있다면 정렬을 한다. 만약 메모리가 부족하게 되면 디스크를 사용할 수도 있다. 너무 많은 메모리를 사용하면 메모리 부하가 있을 수도 있고, 메모리를 사용하지 못하면 메모리 사용에 대한 대기도 일어날 수도 있다.
		3. 레코드 크기가 매우 크다면 네트워크를 통해서 클라이언트로 보내게되는 네트워크 패킷 양도 많아지고, 동시에 여러번 쿼리가 호출된다면 네트워크 부하는 네트워크 대역폭을 풀하게 할 수도 있다.
		4. 다행히 그 데이터가 웹서버나 클라이언트 쪽 네트워크를 통해 버퍼로 전달이 되었다해도 그쪽에서도 대량의 메모리를 처리해야한다.
2. Index 열에 부정형 사용 주의
	```
	ID = {1, 2, 3, 4, 5,6}
	ID <> 3           →  ID > 3 OR ID < 3
	ID !> 10248       →  ID <= 10248 
	ID NOT IN (1,3,5) →  ID <> 1 OR ID <> 3 OR ID <> 5
	ID IN (2, 4, 6)   →  ID = 2 OR ID = 4 OR ID = 6
	```
	1. 조건은 '='이 가장 빠르고 효율적, 범위 조건은 상대적으로 인덱스 효율이 떨어짐
		1. 범위 조건 :  <, >, BETWEEN, LIKE...
	2. (index 조건에 따라) 부정형을 쓰면 옵티마이저가 긍정형으로 자동 변환
		1. 그러나 결과는 항상 범위 검색이 된다.
		2. 불필요한 부정형(범위 검색)은 지양
	3. 검색 범위(행 수)가 적다면 긍정 조건 & 가능하면 '='조건으로 구현
	4. 특히 주의 할 것!
		1. NOT IN (최후의 보루)
		2. 2개 이상의 칼럼으로 구성된 복합 Index 선행 열
			1. 인덱스 만들 때의 순서상 상위에 있는 칼럼에 대해 SARG 위반, Equal 조건이 아닌 조건을 사용하게 되면 인덱스 효율이 떨어지거나 못씀
```
		Ex) PK = 사업장 + 주문일자 + 주문번호
		A) 사업장 LIKE '%' AND 주문일자 = '20211011'
		B) 사업장 IN (1,2,3) AND 주문일자 = '20211011'
```
		    A) 사업장의 LIKE'%'는 의미오류, 처음부터 Equal이 아닌 조건이 나오게 되면 인덱스를 상실함. 주문일자는 Equal 조건으로 되어 있어도 인덱스로 사용되지 않음.
		    B) 사업장에 IN 조건을 쓰면 옵티마이저가 Equal 조건으로 변경해주어 사업장,주문일자 PK를 모두 Equal 조건으로 처리되어 Index를 가장 효율적으로 사용하게 된다.
		    
1. 불필요한 index 열 값 변형
	1. Index 열에 사칙연산
		1. 부등식에 따라 우변/좌변으로 변환
			1. OrderID 에 Index 활용 못함.
``` 
		PK(OrderID ,ProductID)
		WHERE OrderID + 10 = 10268 AND ProductID = 5
		→ OrderID = (10268 - 10) AND ProductID  = 5
```
1. Index 열에 함수 적용
	1. Index 열엔 함수로 가공되지 않도록 구현해야 한다.
```
	WHERE Substring(CustomerID, 1, 3) = 'CEN'
	→ CustomerID LIKE 'CEN%'
	
	WHERE Convert(varchar, OrderDate, 112) = '19960704'
	→ OrderDate BETWEEN '19960704' AND '19960704 11:59..'
	→ OrderDate >= '19960704' AND OrderDate < '19960705'
	
	WHERE DateDiff(dd, ShippedDate, '20240128') <= 1
	→ ShippedDate >= DATEADD(dd, -1, '20240128')

	WHERE ISNULL(OrderDate, '20240128') = '20240128'
	→ (OrderDate = '20240128' OR OrderDate IS NULL)
```
1. Index 열에 암시적 형 변환
	1. 식의 데이터 형식은 열과 동일한 형식으로 맞춘다.
	2. .Net/Javaetc. App에서도 호출 시에도 동일
	3. 서로 다른 타입이 조건식에서 비교되면 양쪽에서 크기가 작은 쪽의 데이터의 암시적 형 변환이 일어난다.
	4. 바이너리를 제외하고 가장 작은 타입은 문자.
	5. 주요 문제 대상
		1. 문자 vs. 숫자
		2. 문자 vs. 날짜
		3. (var)char vs. n(var)char
```
		Index (PK: stor_id, char[4])
		WHERE stor_id >= 6380
		→ stor_id >= '6380'
```
2. 부적절한 LIKE 식
3. 열 간 비교