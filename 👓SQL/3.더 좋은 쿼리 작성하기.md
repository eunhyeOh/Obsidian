# 다룰 내용
- 기본 SQL 권장 사항
- Join 작성 시 권장 사항
- Subquery 작성 시 권장 사항
- 파생 테이블, CTE, APPLY 활용
- 잠금 차단 회피
- 사레들

# 1. 기본 SQL
### 1. IN 조건 vs. BETWEEN
- 용도와 의미에 맞게 선택하여 사용하자.
1. IN
	1. Equal(=) 조건과 OR 연산(합집합)의 결합
		1. Random Access(IO) 동작 (논리연산자 OR 결합으로 인해)
			1. IN 절에 지정한 값의 개수만큼 랜덤하게 액세스가 일어난다.
		2. 검색 대상 값이 많을수록 인덱스 사용 기회가 감소한다.
			1. 검색 대상 값마다 인덱스 검색이 일어나기 때문에 랜덤 IO 반복 횟수가 커져서 일정 값이 넘어가면 그 후는 Index를 사용하지 않고 Scan하는 경우가 발생.
		3. DISTINCT/GROUP BY등은 불 필요
			1. 논리연산자 OR(합집합)이 포함되어 있어 중복값을 자동으로 제거한다.
	2. 비 연속 값 검색 시
	3. 검색 대상이 적은 경우 적합함.
	4. Equal (=) 조건이 필요한 경우
2. BETWEEN 
	1. Non-Equal(>=, <=)조건과 AND 연산의 결합
		1. Sequence Access 동작
	2. (대량의) 연속 값 검색 시 사용


### 2. TOP (N) 활용
1. 쿼리 최적화에 도움을 준다.
	1. 쿼리가 반환하는 데이터 행 수, 검색하는 최종 결과 건수를 Optimizer에게 알려
2. 결과 집합 제한에 활용
	1. TOP (1)
		1. MIN/MAX vs. TOP(1) - Null 값의 처리 방식 이해
			1. 집계함수 MIN,MAX는 NULL값을 제외하고 집계한다.
			2. TOP은 NULL를 한 행으로 포함하여 처리한다.
	2. TOP (n)
		1. Paging 쿼리 (Ex. 게시판)
		2. 전체 결과 집합 제한 (Ex.뉴스, 이벤트 알림, 이력 데이터)
3. TOP + ORDER BY 절 주의
	1. TOP을 사용할 때, Sort때문에 성능 이슈를 고려하거나, 검색 데이터가 PK값이라 자동으로 정렬될 것으로 생각해서 ORDER BY를 생략하는 경우가 많다.
	2. ORDER BY 절 생략하지 마!!!
		1. TOP은 기본적으로 지정된다. 그 기준으로 정의하는 것이니...
		2. ORDER BY절의 Sort에 의해 성능이 느려지는 것이 아니라, Sort를 하지 않아도 되는 적절한 Index가 없거나, Index를 쓰지 못하는 경우에 Sort 연산에 의해 쿼리가 느려지는 것이다. 그럴땐, 인덱스 튜닝, 쿼리 튜닝 필요.
		3. Clustered Index 고려하지 말 것
			1. NOLOCK 힌트 등이 사용될 경우 데이터 정합성 오류 발생 가능
	3. 정렬 데이터의 유일성 보장 필요
		1. 아니면 데이터 일관성 오류 발생 가능
	4. ORDER BY절의 불안전하게 작성
		1. ORDER BY절에 지정한 칼럼에 중복 데이터가 있을 경우, 어떤 데이터를 TOP의 기준이 될 것인가도 명확하게 정의 되어야 한다.
		2. 즉,  각 행을 유일하게 구별할 수 있는 데이터가 같이 ORDER BY에 지정해야 함.
```
	SELECT TOP (5) *
	FROM dbo.[Order Details]
	ORDER BY Quantity DESC 
	→ ORDER BY Quantity DESC, OrderID ASC
```


### 3. 카운트 함수 : COUNT(＊) vs. COUNT(expression)
1. COUINT(＊)
	1. NULL값 포함하여 집계.
2. COUNT(ALL | DISTINCT  expression )
	1. 컬럼을 쓰게 되는 경우, 칼럼이 NULL허용 열이고, NULL제외하고 집계 시 사용.
3. 주의
	1. 데이터 무결성 고려
	2. NULL 허용 열인 경우, COUNT(열)
	3. NOT NULL 열인 경우 두 가지는 동일 동작


### 4. COUNT(＊) vs. EXISTS 연산자
- 용도에 맞게 사용하자.
1. COUNT 함수 : 집계 (전체 검색)
2. EXISTS 연산자 : 데이터 존재 여부 체크(부분 검색)
	1. 조건에 만족하는 첫 번째 행을 만나는 순간 리턴!
3. 2005 버전부터는 동일하게 동작하긴 함.
```
IF (SELECT COUNT(*)
    FROM Eplan.dbo.[Order Details]
    WHERE Quantity > 50
    ) > 0

IF EXISTS (SELECT COUNT(*)
    FROM Eplan.dbo.[Order Details]
    WHERE Quantity > 50)
```

### 5. NULL 고려한 집계 연산
- 대량 NULL값을 가진 열의 경우, 불필요한 NULL 데이터를 사전에 제외되도록 해준다면 집계 함수를 적은 비용을 들여서 효율적으로 쓸 수 있음. (사전 필터링 코드 추가)
- 필터링 코드는 Index를 사용하는 것이 좋다~
```
SELECT SUM(Freight)
FROM dbo.BigOrders
WHERE Freight IS NOT NULL

SELECT MIN(Freight)
FROM dbo.BigOrders
WHERE Freight IS NOT NULL
```


### 6. 불필요한 GROUP BY 열 제거
- PK가 GROUP BY에 포함되어 있다면, 그 뒤 칼럼들은 작성하지 않아도 된다. 
- 그러나 SELECT 칼럼으로 사용하기 위해 기술해야한다며, MIN,MAX의 집계함수를 사용해서 SELECT절에만 작성하자.
```
***PK CustomerID 

SELECT c.CustomerID, c.CompanyName, COUNT(*)
FROM dbo.Customers AS c
INNER JOIN dbo.Orders AS o
...
GROUP BY c.CustomerID, c.CompanyName 

→
SELECT c.CustomerID, MAX(c.CompanyName), COUNT(*)
FROM dbo.Customers AS c
INNER JOIN dbo.Orders AS o
...
GROUP BY c.CustomerID
```


### 7. 합집합 UNION vs. UNION ALL 차이
- 합집합은 중복이 제거된다.
1. UNION
	1. 기본적으로 DISTINCT 연산(중복제거)이 경우에 따라 부하 발생 가능
		1. 행 유일성이 명확한 경우 Optimizer가 자동 조정 가능하나
		2. 명확한 경우 명시적으로 ALL 지정
2. UNION ALL
	1. 명시적으로 중복을 제거한다는 의미.
```
SELECT a, b FROM tableA
UNION 
SELECT a, b FROM tableB

SELECT a, b, FROM tableA
UNION ALL
SELECT a, b FROM tableB
```


### 8.UPDATE결과 열 값 반환, DML 결화 행 반환, 새로운 구문/함수활